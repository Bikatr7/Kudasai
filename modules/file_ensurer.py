## built-in libaries
import os
import traceback

## custom modules
from modules.logger import logger

class fileHandler():

    """
    
    The handler that handles interactions with files.\n

    """
##--------------------start-of-__init__()------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    def __init__(self) -> None:

        """
        
        Initializes the fileHandler class.\n

        Parameters:\n
        None.\n

        Returns:\n
        None.\n

        """

        self.script_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        self.output_dir = os.path.join(self.script_dir, "KudasaiOutput")

        if(os.name == 'nt'):  # Windows
            self.config_dir = os.path.join(os.environ['USERPROFILE'],"KudasaiConfig")
        else:  # Linux
            self.config_dir = os.path.join(os.path.expanduser("~"), "KudasaiConfig")

        ## log file
        self.log_path = os.path.join(self.output_dir, "debug log.txt")

        self.logger = logger(self.log_path)

##-------------------start-of-__init__()---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    def __init__(self) -> None: 

        """
        
        Constructor for the preloader class.\n

        Parameters:\n
        None.\n

        Returns:\n
        None.\n

        """

        self.file_handler = fileHandler()

        self.toolkit = toolkit()

        ##----------------------------------/

        self.lib_dir = os.path.join(self.file_handler.script_dir, "lib")

        self.sudachi_lib = os.path.join(self.lib_dir, "sudachi")
        self.dic_lib = os.path.join(self.lib_dir, "dicts")

        ##----------------------------------/

        self.preprocessed_text_path = os.path.join(self.file_handler.output_dir, "preprocessedText.txt") ## path for the preprocessed text
        self.translated_text_path = os.path.join(self.file_handler.output_dir, "translatedText.txt") ## path for translated text

        self.je_check_path = os.path.join(self.file_handler.output_dir, "jeCheck.txt") ## path for je check text (text generated by the translation modules to compare against the translated text)

        self.kairyou_log_path = os.path.join(self.file_handler.output_dir, "Kairyou Results.txt")  ## path for kairyou log (the results of preprocessing)
        self.error_log_path = os.path.join(self.file_handler.output_dir, "error log.txt") ## path for the error log (errors generated by the preprocessing and translation modules)
        self.debug_log_path = os.path.join(self.file_handler.output_dir, "debug log.txt") ## path for debug log (text generated by the translation modules to help with debugging)

        self.system_zip = os.path.join(self.dic_lib, "system.zip")

        self.katakana_words_path = os.path.join(self.sudachi_lib, "katakana_words.txt")
        self.sudachi_config_json = os.path.join(self.sudachi_lib, "sudachi.json")
        self.sudachi_system_dic = os.path.join(self.dic_lib, "system.dic") 

        self.setup_needed_files()

##-------------------start-of-setup_needed_files()---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    def setup_needed_files(self) -> None:

        """

        spits out output file paths and creates the required directories for them\n
        
        Parameters:\n
        self (object - Kudasai) : the Kudasai object.\n

        Returns:\n
        None\n

        """

        ## creates the output directory and config directory if they don't exist
        self.file_handler.standard_create_directory(self.file_handler.config_dir)
        self.file_handler.standard_create_directory(self.file_handler.output_dir)

        ## creates and clears the log file
        self.file_handler.logger.clear_log_file()

        ## creates the remaining 5 output files
        self.file_handler.standard_create_file(self.preprocessed_text_path)
        self.file_handler.standard_create_file(self.translated_text_path)
        self.file_handler.standard_create_file(self.je_check_path)
        self.file_handler.standard_create_file(self.kairyou_log_path)
        self.file_handler.standard_create_file(self.error_log_path)

        if(not os.path.exists(self.katakana_words_path)):
           raise FileNotFoundError(f"Katakana words file not found at {self.katakana_words_path}")

##--------------------start-of-standard_create_directory()------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    def standard_create_directory(self, directory_path:str) -> None:

        """

        Creates a directory if it doesn't exist, as well as logs what was created.\n

        Parameters:\n
        self (object - fileHandler) : the fileHandler object.\n
        directory_path (str) : path to the directory to be created.\n

        Returns:\n
        None.\n

        """

        if(os.path.isdir(directory_path) == False):
            os.mkdir(directory_path)
            self.logger.log_action(directory_path + " created due to lack of the folder")

##--------------------start-of-standard_create_file()------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    def standard_create_file(self, file_path:str) -> None:

        """

        Creates a file if it doesn't exist, truncates it,  as well as logs what was created.\n

        Parameters:\n
        self (object - fileHandler) : the fileHandler object.\n
        file_path (str) : path to the file to be created.\n

        Returns:\n
        None.\n

        """

        if(os.path.exists(file_path) == False):
            self.logger.log_action(file_path + " was created due to lack of the file")
            with open(file_path, "w+", encoding="utf-8") as file:
                file.truncate()

##--------------------start-of-modified_create_file()------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    def modified_create_file(self, file_path:str, content_to_write:str) -> None:

        """

        Creates a path if it doesn't exist or if it is blank or empty, writes to it, as well as logs what was created.\n

        Parameters:\n
        self (object - fileHandler) : the fileHandler object.\n
        file_path (str) : path to the file to be created.\n
        content to write (str) : content to be written to the file.\n

        Returns:\n
        None.\n

        """

        if(os.path.exists(file_path) == False or os.path.getsize(file_path) == 0):
            self.logger.log_action(file_path + " was created due to lack of the file or because it is blank")
            with open(file_path, "w+", encoding="utf-8") as file:
                file.write(content_to_write)

##--------------------start-of-standard_overwrite_file()------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    def standard_overwrite_file(self, file_path:str, content_to_write:str, omit:bool = False) -> None:

        """

        Writes to a file, creates it if it doesn't exist, overwrites it if it does, as well as logs what occurred.\n

        Parameters:\n
        self (object - fileHandler) : the fileHandler object.\n
        file_path (str) : path to the file to be overwritten.\n
        content to write (str) : content to be written to the file.\n

        Returns:\n
        None.\n

        """

        with open(file_path, "w+", encoding="utf-8") as file:
            file.write(content_to_write)

        if(omit):
            content_to_write = "omitted"
        
        self.logger.log_action(file_path + " was overwritten with the following content: " + content_to_write)

##-------------------start-of-handle_critical_exception()---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    def handle_critical_exception(self, critical_exception:Exception) -> None:

        """

        Handles a critical exception by logging it and then throwing it.\n

        Parameters:\n
        self (object - fileHandler) : the fileHandler object.\n
        critical_exception (object - Exception) : the exception to be handled.\n

        Returns:\n
        None.\n

        """

        ## if crash, catch and log, then throw
        self.logger.log_action("--------------------------------------------------------------")
        self.logger.log_action("Kudasai has crashed")

        traceback_str = traceback.format_exc()
        
        self.logger.log_action(traceback_str)

        self.logger.push_batch()

        raise critical_exception
